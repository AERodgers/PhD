# OPEN SOUNDS & TEXTGRIDS CONTAINING SPECIFIED PHONOLOGICAL STRUCTURE
# ===================================================================
# Written for Praat 6.0.36

# Antoin Eoin Rodgers
# rodgeran@tcd.ie
# Phonetics and speech Laboratory, Trinity College Dublin
# May 22 2018

# Note this scripts requires the table generated by the "process_textgrids" script in order to work.
# The script will end with an error if the the target text does not exist in any phonological structure.

##############
### USER INPUT
form open textgrids containing given text in phonological analysis
    sentence target_text [
    optionmenu field 3
        option code
        option sentence
        option phonology
    optionmenu search_type 3
        option is equal to
        option is not equal to
        option contains
        option does not contain
        option starts with
        option does not start with
        option ends with
        option does not end with
        option contains a word equal to
        option does not contain a word equal to
        option contains a word starting with
        option does not contain a word starting with
        option contains a word ending with
        option does not contain a word ending with
        option matches (regex)

    sentence table_directory C:\Users\antoi\OneDrive\00 Academic\Phonetics and speech\PhD - Derry Intonation\2 Field Recordings\Analysis_1_standard
    sentence table_file m_corpus.Table
    comment Select tiers to HIDE ("syllable" is necessary)
    boolean ortho 1
    boolean rhythmic 0
    boolean phono 0
    boolean phonetic 1
    boolean vowel 1
    boolean tone 0
    boolean foExtrema 1
    boolean perpLine 1
    boolean maxK 1
    boolean hDur_LDur 1
    boolean comments 0
endform

field$# = {"code", "sentence", "phonology"}

search_type$[1] = "is equal to"
search_type$[2] = "is not equal to"
search_type$[3] = "contains"
search_type$[4] = "does not contain"
search_type$[5] = "starts with"
search_type$[6] = "does not start with"
search_type$[7] = "ends with"
search_type$[8] = "does not end with"
search_type$[9] = "contains a word equal to"
search_type$[10] = "does not contain a word equal to"
search_type$[11] = "contains a word starting with"
search_type$[12] = "does not contain a word starting with"
search_type$[13] = "contains a word ending with"
search_type$[14] = "does not contain a word ending with"
search_type$[15] = "matches (regex)"

# create vector of DB field names
db_field$# = {"code","sent","phr_phon"}

# create string of tiers to remove
hide_tiers$ = ""
if ortho = 1
    hide_tiers$ += "ortho "
endif
if rhythmic = 1
    hide_tiers$ += "rhythmic "
endif
if phono = 1
    hide_tiers$ += "phono "
endif
if phonetic = 1
    hide_tiers$ += "phonetic "
endif
if vowel = 1
    hide_tiers$ += "vowel "
endif
if tone = 1
    hide_tiers$ += "tone "
endif
if foExtrema = 1
    hide_tiers$ += "foExtrema "
endif
if perpLine = 1
    hide_tiers$ += "perpLine "
endif
if maxK = 1
    hide_tiers$ += "maxK "
endif
if hDur_LDur = 1
    hide_tiers$ += "HDur LDur "
endif
if comments = 1
    hide_tiers$ += "comments "
endif

last$ = right$(hide_tiers$, 1)
if last$ = " "
    hide_tiers$ = left$(hide_tiers$, length(hide_tiers$) - 1)
endif


### PROCESS FILES
# Get analysis table
table_directory$ = replace$(
                        ... replace$(table_directory$ + "/", "\", "/", 0),
                        ... "//",
                        ..."/",
                        ... 0)

# Get list of valid files
batch_data = Read from file: table_directory$ + table_file$
temp_table = nowarn Extract rows where column (text):
         ... db_field$#[field], search_type$[search_type], target_text$
short_table =  nowarn Extract rows where: "self[""cur_foot""]=1"
num_rows = Get number of rows
removeObject: {batch_data, temp_table}
previous_grid$ = "XKCD_is_a_highly_unlikely_name"


# write all indices and grid names in info window
writeInfoLine: "Indices & File Codes'newline$'===================='newline$'"
appendInfoLine:
    ... "+-----------------------+-----------------------+-------------------"
appendInfoLine: "|index", tab$, "file",
            ... tab$, tab$, "| index", tab$, "file",
            ... tab$, tab$, "|index", tab$, "file"
appendInfo:
    ... "+-----------------------+-----------------------+-------------------"

i = 0
while i < num_rows
    i += 1
    cur_code$ = Get value: i, "code"
    appendInfo: newline$, "| ", i, tab$, cur_code$
    i += 1
    if i <= num_rows
        cur_code$ = Get value: i, "code"
        appendInfo: tab$, "| ", i, tab$, cur_code$
    endif
    i += 1
    if i <= num_rows
        cur_code$ = Get value: i, "code"
        appendInfo: tab$, "| ", i, tab$, cur_code$
    endif
endwhile

appendInfoLine: "'newline$''newline$'Looking for each " + field$#[field] +
            ... " which " + search_type$[search_type] + " ""'target_text$'""."
duplicates = 0

# MAIN LOOP

# Menu Response Choices
edit_choice = 0
.choice$[6] = "Save >"
.choice$[5] = ">"
.choice$[4] = "Save"
.choice$[3] = "Undo"
.choice$[2] = "<"
.choice$[1] = "Exit"

i = 0
while i < num_rows
    i += 1
    i_adjust = 0
    duplicates += 1

    selectObject: short_table
    cur_location$ = Get value: i, "location"
    curDrive$ = left$(cur_location$, 3)
    cur_location$ = replace$(
                        ... cur_location$,
                        ... curDrive$,
                        ... left$(table_directory$, 3),
                        ... 1
                        ... )
    cur_grid$ = Get value: i, "code"
    # avoid loading duplicate sounds and textgrids
    if cur_grid$ != previous_grid$
        Read from file: cur_location$ + cur_grid$ + ".TextGrid"
        cur_grid = selected ()

        Read from file: cur_location$ + cur_grid$ + ".wav"
        Scale intensity: 70
        previous_grid$ = cur_grid$
        cur_sound = selected ()
        appendInfo: newline$, "Looking at: ", cur_grid$
        # remove tiers for temporary textgrid, if any have been specified
        if length(hide_tiers$) != 0
            @temp_textgrid: "cur_grid", hide_tiers$
            selectObject: temp_textgrid.object
            plusObject: cur_sound
        else
            selectObject: cur_grid
            plusObject: cur_sound
        endif

		# pause for editting
        Edit
        pauseText$ = "Editing 'i'/'num_rows': 'cur_grid$'"
        beginPause: pauseText$
            natural: "Jump to", i + 1
        edit_choice = endPause:
                    ... "Exit", "<", "Undo", "Save", ">", "Save >", 5, 0

        # Merge textgrid tiers.
        if length(hide_tiers$) != 0
            @merge_textgrids
        endif

        # Process Edit Choices
        if .choice$[edit_choice] = "Save >"
            selectObject: cur_grid
            Save as text file: cur_location$ + cur_grid$ + ".TextGrid"
            i_adjust = jump_to - 1 - i
        elsif .choice$[edit_choice] = ">"
            i_adjust = jump_to - 1 - i
        elsif .choice$[edit_choice] = "Save"
            selectObject: cur_grid
            Save as text file: cur_location$ + cur_grid$ + ".TextGrid"
            i_adjust = -1
        elsif .choice$[edit_choice] = "Undo"
            i_adjust = -1
        elsif .choice$[edit_choice] = "<"
            i_adjust = -2
            if (jump_to != i + 1)
                i_adjust = jump_to - 1 - i
            endif
        endif

        # Adjust i.
        i += i_adjust
        if i > num_rows
            i = num_rows - 1
        elsif i < 0
            i = 0
        endif

        #Remove Current Objects
        duplicates = 0
        removeObject: {cur_grid, cur_sound}

        # Check for exit script
        i += i * 10e10 * (edit_choice = 1)

    endif
endwhile

# remove unwanted objects
removeObject: short_table

include procs/tempTextGrids.proc
