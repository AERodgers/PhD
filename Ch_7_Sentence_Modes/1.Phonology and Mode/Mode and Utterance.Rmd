---
title: 'Chapter 07: Analysis of Function'
subtitle: 'Sentence Mode and Utterance Phonology'
output:
  html_document: default
  word_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE)


# Load Functions.
source("../../functions/myFunctions.R") 

# Load packages.
installMissingPackages(
  c(
    # Load tidy packages.
    "formattable",
    "janitor",
    "kableExtra",
    "RColorBrewer",
    "tidyverse",
    "ggeffects",
    # Load stats package.
    "blme"
  )
)

# Set themes and colour schemes.
theme_set(theme_minimal(base_size = 10))

# Change this as required
options("speakr.praat.path" = "C:/Program Files/Praat/Praat.exe")

## set colours

mode_colours <- c("MDC" = brewer.pal(4, "Dark2")[3],
                  "MWH" = brewer.pal(4, "Dark2")[2],
                  "MYN" = brewer.pal(4, "Dark2")[1],
                  "MDQ" = brewer.pal(4, "Dark2")[4])
p_color <- all_models_tidy ~ style(color =
                                     if_else(as.double(all_models_tidy) < 0.05,
                                             "green",
                                             "red")
                                   )
pitch_accent_colours <- c("H*"     = brewer.pal(6, "Set2")[5],
                          "L*H"    = brewer.pal(6, "Set2")[3],
                          "^[L*]H" = brewer.pal(6, "Set2")[6],
                          ">H*"    = brewer.pal(6, "Set2")[4],
                          "L*^[H]" = brewer.pal(6, "Set2")[2],
                          "^[L*H]" = brewer.pal(6, "Set2")[1])
```

```{r load and process corpus, include=FALSE}
m_corpus <- get_m_corpus("../data/m_corpus.csv")  %>%
  # Consolidate nuc_contour based on observation and types of register shift.
  mutate(
    # remove non-accentuation from phr_phon
    phr_phon = str_replace_all(phr_phon, "\\(\\*\\)", ""),
    `nuclear PA only` = factor(str_count(phr_phon, "\\*") == 1,
                               levels = c(F, T)),
    `high register in nucleus` = factor(str_detect(acc_phon, "\\^"),
                                        levels = c(F, T)),
    `high reg. or nuc. PA only` = factor(
      `high register in nucleus` == T | `nuclear PA only` == T,
      levels = c(F, T))
  ) %>%
  # Select only columns for analysis
  select(speaker,
         gender,
         mode,
         prompt,
         phr_phon,
         `nuclear PA only`,
         `high register in nucleus`,
         
         `high reg. or nuc. PA only`)


```

# **Analysis of Raw Data**

## Utterance level intonational phonology

```{r Prep. for utterance-level phonology, warning=FALSE}
#set lower limit for list: more than 8 tokens in the corpus
tot_rows = nrow(m_corpus)
threshold = round(tot_rows / 4 / 20,0)

keep_list <- m_corpus %>%
  mutate(phr_phon = factor(phr_phon, levels = unique(phr_phon))) %>%
  group_by(phr_phon) %>%
  summarise(phon_count = n()) %>% 
  filter(phon_count >= threshold)

# List all utterance phonology
m_corpus %>%
  mutate(phr_phon = factor(phr_phon, levels = unique(phr_phon))) %>%
  group_by(phr_phon) %>%
  summarise(phon_count = n()) %>%
  arrange(desc(phon_count)) %>%
  mutate(
    phr_phon = str_replace_all(phr_phon, "([\\*\\[\\^\\>])", "\\\\\\1")
    ) %>%
  formattable(
    caption = "Utterance level intonational phonology in M-corpus ")

# get tibble of total counts per cell 
total_counts <- m_corpus %>%
  group_by(mode) %>%
  summarise(phon_count = n(), .groups="rowwise") %>%
  arrange(desc(phon_count)) %>%
  pivot_wider(names_from = mode,
              values_from = phon_count,
              values_fill = 0) %>% 
  mutate(total = sum(c_across())) %>%
  select(MDC, MWH, MYN, MDQ, total) 


```


```{r Show nuc only utterance level phonology summary, warning=FALSE}
nuc_only <- m_corpus %>%
  filter(`nuclear PA only` == TRUE) %>%
  group_by(mode) %>%
  summarise(phon_count = n(), .groups="rowwise") %>%
  arrange(desc(phon_count)) %>%
  pivot_wider(names_from = mode,
              values_from = phon_count,
              values_fill = 0) %>% 
  mutate(total = sum(c_across())) %>%
  select(MDC, MWH, MYN, MDQ, total)

nuc_only %>% 
  rbind(round((nuc_only / total_counts*100),1) %>% paste("%", sep="")) %>% 
  mutate("info" =c("count", "percentage"), .before=1) %>%
  kable(
  caption = "Utterance level intonational phonology by mode for tokens with only one PA")%>% 
  kable_styling(full_width = FALSE, position="left")
```


```{r Show `high register in nucleus` utterance level phonology summary, warning=FALSE}
uses_h_reg <- m_corpus %>%
  filter(`high register in nucleus` == T) %>%
  group_by(mode) %>%
  summarise(phon_count = n(), .groups="rowwise") %>%
  complete(mode, fill=list(phon_count=0)) %>% 
  arrange(desc(phon_count)) %>%
  pivot_wider(names_from = mode,
              values_from = phon_count,
              values_fill = 0) %>% 
  mutate(total = sum(c_across())) %>%
  select(MDC, MWH, MYN, MDQ, total)

uses_h_reg %>% 
  rbind(round((uses_h_reg / total_counts*100),1) %>% paste("%", sep="")) %>% 
  mutate("info" =c("count", "percentage"), .before=1) %>%
  kable(
  caption = "High register in nucelar PA")%>% 
  kable_styling(full_width = FALSE, position="left")
```


```{r Show `high reg. or nuc. PA only` utterance level phonology summary, warning=FALSE}
uses_h_reg_or_nuc_PA_only <- m_corpus %>%
  filter(`high register in nucleus` == T | `nuclear PA only` == T) %>%
  group_by(mode) %>%
  summarise(phon_count = n(), .groups="rowwise") %>%
  arrange(desc(phon_count)) %>%
  pivot_wider(names_from = mode,
              values_from = phon_count,
              values_fill = 0) %>% 
  mutate(total = sum(c_across())) %>%
  select(MDC, MWH, MYN, MDQ, total)

uses_h_reg_or_nuc_PA_only %>% 
  rbind(round((uses_h_reg_or_nuc_PA_only / total_counts*100),1) %>% paste("%", sep="")) %>% 
  mutate("info" =c("count", "percentage"), .before=1) %>%
  kable(
  caption = paste("Utterance level intonational phonology by mode with",
                  "high register or nuclear PA only"))%>% 
  kable_styling(full_width = FALSE, position="left")
```


```{r Show distribution of utterance level phonology by mode, warning=FALSE}
# List utterances phonology by mode with 8+ tokens in the corpus
m_corpus %>%
  mutate(phr_phon = factor(phr_phon, levels = unique(phr_phon))) %>%
  filter(phr_phon %in% keep_list$phr_phon) %>%
  group_by(mode, phr_phon) %>%
  summarise(phon_count = n(), .groups="rowwise") %>%
  arrange(desc(phon_count)) %>%
  mutate(phr_phon = str_replace_all(phr_phon,
                                    "([\\*\\[\\^\\>])", "\\\\\\1")) %>%
  pivot_wider(names_from = mode,
              values_from = phon_count,
              values_fill = 0) %>%
  select(phr_phon, MDC, MWH, MYN, MDQ) %>%
  rowwise(phr_phon) %>%
  mutate(total = sum(c_across())) %>%
  tibble::rowid_to_column("#") %>%
  rename("Phonology" = phr_phon) %>%
  formattable(
    align = "r",
    caption = paste(
      "Utterance level intonational phonology by mode ",
      "for tokens accounting for at least ",
      percent(threshold / tot_rows),
      " of all tokens.",
      sep = ""
    ),
    list(
      area(col = 3:6) ~ proportion_bar(color = c(
        rep(brewer.pal(4, "Pastel2")[3], nrow(.)),
        rep(brewer.pal(4, "Pastel2")[2], nrow(.)),
        rep(brewer.pal(4, "Pastel2")[1], nrow(.)),
        rep(brewer.pal(4, "Pastel2")[4], nrow(.))
        )),
      total = proportion_bar(color = "#aaaaaa")
    )
  )
```

# **Statistical Analysis**
```{r nuc_pa_only_model}

nuc_pa_only_model <- bglmer(
  `nuclear PA only` ~ mode + gender + (1 | speaker) + (1 | prompt),
  data = m_corpus,
  family = binomial(link = "logit"),
  # change optimizer to avoid convergence errors
  control = glmerControl(
    optimizer = "optimx",
    calc.derivs = FALSE,
    optCtrl = list(
      method = "nlminb",
      starttests = FALSE,
      kkt = FALSE
    )
  )
)

nuc_pa_only_model_null = 
  cur_model <- bglmer(
  `nuclear PA only` ~ 1 + (1 | speaker) + (1 | prompt),
  data = m_corpus,
  family = binomial(link = "logit"),
  # change optimizer to avoid convergence errors
  control = glmerControl(
    optimizer = "optimx",
    calc.derivs = FALSE,
    optCtrl = list(
      method = "nlminb",
      starttests = FALSE,
      kkt = FALSE
    )
  )
)

summary(nuc_pa_only_model)
```

```{r extra chart one PA}
ggpredict(nuc_pa_only_model, terms=c("mode")) %>%
  as.tibble() %>% 
  select(-group) %>% 
  rename(mode = x) %>%
  relocate(std.error, .after = conf.high) %>%
  mutate(across(2:last_col(),
         ~ (round(., 3))),
         across(2:4,
         ~ percent(., 1))) %>% 
  formattable(caption="probability of nuclear pitch-accent-only IP")
```

```{r nuc_pa_only_model charts and figures, fig.width = 5.5, fig.height = 2.5, results="asis"}
cat(
  "\nisSingular(nuc_pa_only_model, tol=1e-5) -->",
  isSingular(nuc_pa_only_model, tol = 1e-5),
  "\n"
)

# get, save, and print ANOVA of model
anova(nuc_pa_only_model, nuc_pa_only_model_null, test="Chisq") %>%
  outputChiSqResults(
    nuc_pa_only_model,
    extra_text = "(assuming no register tier)",
    write="Utt_nuc_pa_only_GLMM",
    post_hoc_method = "BH"
  )

tidy_summary <- analyseModel(nuc_pa_only_model,
                             write = "Utt_nuc_pa_only_GLMM",
                             is_GLM = TRUE,
                             factor_matrix = TRUE,
                             type = "pred")


tidy_summary$table

nuc_pa_only_charts <- getModelFixedFX(
  my_equation = `nuclear PA only` ~ mode + gender + (1 | speaker) + (1 | prompt),
  my_data = m_corpus,
  write = "Utt_nuc_pa_only_GLMM",
  is_GLM = TRUE
)


nuc_pa_only_charts$intercepts
nuc_pa_only_charts$slopes
```

```{r `high reg. or nuc. PA only` model}
h_reg_or_nuc_pa_only_model <- bglmer(
  `high reg. or nuc. PA only` ~ mode + gender +(1 | speaker) + (1 | prompt),
  data = m_corpus,
  family = binomial(link = "logit"),
  # change optimizer to avoid convergence errors
  control = glmerControl(
    optimizer = "optimx",
    calc.derivs = FALSE,
    optCtrl = list(
      method = "nlminb",
      starttests = FALSE,
      kkt = FALSE
    )
  )
)

h_reg_or_null = 
  cur_model <- bglmer(
   `high reg. or nuc. PA only` ~ 1 + (1 | speaker) + (1 | prompt),
  data = m_corpus,
  family = binomial(link = "logit"),
  # change optimizer to avoid convergence errors
  control = glmerControl(
    optimizer = "optimx",
    calc.derivs = FALSE,
    optCtrl = list(
      method = "nlminb",
      starttests = FALSE,
      kkt = FALSE
    )
  )
)

summary(h_reg_or_nuc_pa_only_model)
```



```{r extra chart Charts5}
ggpredict(h_reg_or_nuc_pa_only_model, terms=c("mode")) %>%
  as.tibble() %>% 
  select(-group) %>% 
  rename(mode = x) %>%
  relocate(std.error, .after = conf.high) %>%
  mutate(across(2:last_col(),
         ~ (round(., 3))),
         across(2:4,
         ~ percent(., 1))) %>% 
  formattable(caption="Probability of either high register or nuclear-PA-only IP")
```


```{r h_reg_or_nuc_pa only model charts and figures, fig.width = 5.5, fig.height = 2.5, results="asis"}
cat(
  "isSingular(h_reg_or_nuc_pa_only_model, tol=1e-5) -->",
  isSingular(h_reg_or_nuc_pa_only_model, tol = 1e-5),
  "\n"
)

anova(h_reg_or_nuc_pa_only_model, h_reg_or_null, test="Chisq") %>%
  outputChiSqResults(
    h_reg_or_nuc_pa_only_model,
    extra_text = "(assuming no register tier)",
    write="Utt_h_reg_or_nuc_pa_only_GLMM",
    post_hoc_method = "BH"
  )

tidy_summary <- analyseModel(h_reg_or_nuc_pa_only_model,
                    write = "Utt_h_reg_or_nuc_pa_only_GLMM",
                    is_GLM = TRUE,
                    type = "pred"
                    )


tidy_summary$table

h_reg_or_charts <- getModelFixedFX(
  my_equation = 
    `high reg. or nuc. PA only` ~ mode + gender + (1 | speaker) + (1 | prompt),
  my_data = m_corpus,
  write = "Utt_h_reg_or_nuc_pa_only_GLMM",
  is_GLM = TRUE
)


h_reg_or_charts$intercepts
h_reg_or_charts$slopes

```
