---
title: 'Chapter 07: Analysis of Function: Sentence Modes and Nuclear Contours without a Register Tier'
output:
  html_document: default
  word_document: default
  pdf_document: default
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE)


# Load Functions.
source("../../functions/myFunctions.R") 

# Load packages.
installMissingPackages(
  c(
    # Include statistical packages.
    "lmerTest",
    "lme4",
    "optimx",
    "MuMIn",
    
    # Include packages for tidy output.
    "broomExtra",
    "formattable",
    "janitor",
    "knitr",
    "RColorBrewer",
    "sjPlot",
    "tidyverse",
    
    # Include packages for %in% %notin% syntactic notation
    "mefa4"
  )
)

# Set themes and colour schemes.
theme_set(theme_minimal(base_size = 18))

# Change this as required
options("speakr.praat.path" = "C:/Program Files/Praat/Praat.exe")

## set colours
p_color <- all_models_tidy ~ style(color =
                                     if_else(as.double(all_models_tidy) < 0.05,
                                             "green",
                                             "red")
                                   )
nuc_contour_colours <- c(
  "L*H %"   = brewer.pal(6, "Set2")[3],
  "L*H L%" = brewer.pal(8, "Set2")[7],
  ">H* L%"  = brewer.pal(6, "Set2")[4],
  "H* L%"   = brewer.pal(6, "Set2")[5],
  "L*H H%" = brewer.pal(6, "Set2")[2],
  "L*H HL%" = brewer.pal(8, "Set2")[8]
)

fin_phon_colours <- c(
  "%"   = brewer.pal(6, "Set2")[3],
  "L%" = brewer.pal(8, "Set2")[7],
  "H%" = brewer.pal(6, "Set2")[2],
  "HL%" = brewer.pal(8, "Set2")[8]
)

# Get  Data.
m_corpus <- get_m_corpus("../data/m_corpus.csv")  %>%
    mutate(
      # replace L*^[H] % with L*H H% and L*^[H] L% with L*H HL%
      fin_phon = if_else(
        acc_phon == "L*^[H]" & fin_phon != "L%", "H%", if_else(
          acc_phon == "L*^[H]" & fin_phon == "L%", "HL%",fin_phon)
        ),
      acc_phon = if_else(
        acc_phon == "L*^[H]" & (fin_phon == "H%" | fin_phon == "HL%"),
        "L*H",
        acc_phon),
      nuc_contour = paste(acc_phon, fin_phon, sep=" "),
      phr_phon = str_replace(phr_phon, "L\\*\\^\\[H\\] %", "L\\*H H%"),
      phr_phon = str_replace(phr_phon, "L\\*\\^\\[H\\] L%", "L\\*H HL%"),
      # remove register tier
      phr_phon = factor(str_replace_all(phr_phon, "\\^|\\[|\\]", ""),
                        levels = unique(phr_phon)),
      acc_phon = factor(str_replace_all(acc_phon, "\\^|\\[|\\]", ""),
                        levels = unique(acc_phon)),
      nuc_contour = factor(str_replace_all(nuc_contour, "\\^|\\[|\\]", ""),
                           levels = unique(nuc_contour)),
      fin_phon = factor(str_replace_all(fin_phon, "]", ""),
                        levels = unique(fin_phon))
  )%>%
  # Select only columns for analysis
  select(speaker,
         gender,
         mode,
         prompt,
         stim,
         phr_phon,
         nuc_contour,
         acc_phon,
         fin_phon)

```
It is clear that there is little relationship between the pitch accent and mode when the register tier is discounted. However, looking at the raw data for the phrase-level phonology, it looks like L% boundaries are more commonly associated with questions than declaratives.

Therefore, it might be worth looking at the nuclear contour as a whole in this data set.

    
```{r warning=FALSE}
# Create tibble summarising  proportion of nuclear contours per mode per speaker
nuc_contour_adj <- m_corpus %>%
  # Count the number of nuc_contour by speaker and mode
  group_by(speaker, stim, nuc_contour) %>%
  summarise(nuc_count = n(), .groups = "keep") %>%
  pivot_wider(names_from = nuc_contour,
              values_from = nuc_count,
              values_fill = 0) %>%
  # convert the totals to proportion per stim.
  adorn_totals("col") %>%
  mutate(across(3:6,  ~  (. / Total))) %>%
  select(-Total) %>%
  # Convert stim column to mode.
  rename(mode = stim) %>%
  mutate(mode = substr(mode, 1, 3)) %>%
  # Convert the values to proportion per mode
  pivot_longer(3:last_col(), "nuc_contour") %>%
  group_by(speaker, mode, nuc_contour) %>%
  pivot_wider(
    names_from = nuc_contour,
    values_from = value,
    values_fill = 0,
    values_fn = ~ sum(.)
  ) %>%
  adorn_totals("col") %>%
  mutate(across(3:6, ~ (. / Total)),
         mode = factor(mode, levels = c("MDC", "MWH", "MYN", "MDQ"))) %>%
  select(-Total) %>%
  as_tibble()

# Create tibble of nuclear contours per speaker (adjusted).
nuc_contour_by_speaker_adj <- nuc_contour_adj %>%
  # Get the sum of all token proportions per speaker.
  pivot_longer(3:last_col(), "nuc_contour") %>%
  select(-c(mode)) %>% 
  pivot_wider(names_from = nuc_contour,
              values_from = value,
              values_fill = 0,
              values_fn = ~ sum(.)
              ) %>%
  # Convert proportions to an integer based on an ideal total number of tokens
  # per speaker.
  mutate(across(2:5, ~ round(. * 15, 0))) %>% 
  write_csv("nuc_contour_by_speaker_adj.csv")

# Create tibble of nuclear contours per mode (adjusted).
nuc_contour_by_mode_adj <- nuc_contour_adj %>%
  # Get the sum of all token proportions per speaker.
  pivot_longer(3:last_col(), "nuc_contour") %>%
  select(-c(speaker)) %>% 
  pivot_wider(names_from = nuc_contour,
              values_from = value,
              values_fill = 0,
              values_fn = ~ sum(.)
              ) %>% 
  # Convert proportions to an integer based on an ideal total number of tokens.
  mutate(across(2:5, ~ round(. * 15, 0))) %>% 
  arrange(mode) %>% 
  write_csv("nuc_contour_by_mode_balanced.csv")

# Create tibble of nuclear contours by gender and mode (adjusted).
nuc_contour_by_gender_adj <- nuc_contour_adj %>% 
  # Convert gender to speaker
  mutate(speaker = substr(speaker, 1, 1),
         speaker = factor(speaker, levels=unique(speaker))) %>% 
  rename(gender = speaker) %>% 
  # Get the sum of all token proportions per speaker.
  pivot_longer(3:last_col(), "nuc_contour") %>%

  pivot_wider(names_from = nuc_contour,
              values_from = value,
              values_fill = 0,
              values_fn = ~ sum(.)
              ) %>%
  # Convert proportions to an integer based on an ideal total number of tokens
  # per speaker.
  mutate(across(3:6, ~ if_else(gender=="F",
                               round(. * 15, 0),
                               # project equal number of Male & Female speakers.
                               round(. * 18, 0)
                               )
                )
         ) %>% 
  arrange(mode) %>% 
  write_csv("nuc_contour_by_mode_and_gender_adj.csv")

```
## Nuclear contour

### Nuclear contour by Speaker
```{r warning=FALSE}
nuc_contour_by_speaker_adj %>%
  write_csv("nuc_by_speaker_adj.csv")  %>%
  rename_all(list(~str_replace_all(., "([\\*\\[\\^\\>])", "\\\\\\1"))) %>%  
  adorn_totals(where = "row") %>% 
  formattable(
    caption="Distibution by speaker of nuclear contours in M-corpus (adjusted)",
    align="r",
    list(area(col = 2:6, row=1:nrow(.)-1) ~ proportion_bar(color = c(
      rep(brewer.pal(8, "Pastel2")[3], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[7], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[2], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[4], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[5], nrow(.)-1)
      )))
    )
```


```{r warning=FALSE}
nuc_contour_by_speaker_adj_uncount <- nuc_contour_by_speaker_adj %>%
    gather("nuc_contour", "count",-c(speaker)) %>%
    uncount(count)

```

```{r warning=TRUE, fig.width = 10, fig.height = 4}
# Percentage Stacked bar

ggplot(data = nuc_contour_by_speaker_adj_uncount %>%
         mutate(nuc_contour = factor(
           nuc_contour,
           levels = c("L*H H%", "L*H HL%", "L*H L%", "H* L%",  ">H* L%", "L*H %")
         )),
       aes(fill = nuc_contour, x = speaker)) +
  geom_bar(
    stat = "count",
    position = "fill",
    width = 0.30,
    colour = "black"
  ) +
  scale_fill_manual(values = nuc_contour_colours) +
  
  labs(y = "Proportion of nuclear contours",
       x = "Speaker") +
  theme(panel.border = element_rect(fill = NA)) +
  scale_y_continuous(sec.axis = sec_axis(~ . * 3 + 4))
```

### Nuclear contour by Sentence Mode

```{r warning=FALSE}
# Calculate a projected balanced number of tokens for each PA as a function of # sentence mode.
#
# This takes into consideration the number of utterances per speaker per stimulus and the number of speakers per stimulus.

nuc_contour_by_mode_adj %>%
  rename_all(list( ~ str_replace_all(., "([\\*\\[\\^\\>])", "\\\\\\1"))) %>%
  adorn_totals("row") %>%
  formattable(caption =
                "Distibution by mode of nuclear contours in M-corpus (adjusted)",
    list(area(col = 2:7, row=1:nrow(.)-1) ~ proportion_bar(color = c(
      rep(brewer.pal(8, "Pastel2")[3], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[7], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[2], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[8], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[4], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[5], nrow(.)-1)
      )))
  )

```

```{r warning=FALSE}

# Get list of projected PA tokens by mode and gender.
nuc_contour_by_gender_adj_list <- nuc_contour_by_gender_adj %>%
    pivot_longer(3:last_col(), "nuc_contour") %>%
    uncount(value) %>% 
    mutate(nuc_contour = factor(nuc_contour, levels = unique(nuc_contour)))

```

```{r, fig.height=7, fig.width=15}
ggplot(nuc_contour_by_gender_adj_list) +
  geom_bar(
    mapping = aes(
      x = mode,
      y = (..count..) / sum(..count..),
      fill = nuc_contour
    ),
    show.legend = FALSE,
    colour = "black",
    position = position_dodge2(preserve = "single")
  ) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.14)) +
  facet_grid(rows = vars(gender), cols = vars(nuc_contour)) +
  ggtitle("Nuclear contours by sentence mode and gender (adjusted)") +
  theme(
    panel.border = element_rect(fill = NA),
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16)
  ) +
  ggtitle("nuclear contours by sentence mode (adjusted)") +
  scale_fill_manual(values = nuc_contour_colours, name = "nuclear contour") +
  labs(x = "Mode", y = "tokens (%)") +
  theme(panel.border = element_rect(fill = NA)) +
  geom_text(aes(
    x = mode,
    y = (..count..) / sum(..count..),
    label = percent((..count..) / sum(..count..), 1)
  ),
  stat = "count",
  vjust = -0.75)

```

It appears that the male speakers are more likely to begin using L% across the question mode hierarchy more than the female speakers. There are not enough speakers, I believe, however, to justify this as a general conclusion, especially as it is only M8, M9, and M10 who do this.

```{r fig.height=4, fig.width=14.5}
nuc_contour_by_mode_adj_list <- nuc_contour_by_mode_adj %>%
  pivot_longer(2:last_col(), "nuc_contour") %>%
    uncount(value) %>%
    mutate(nuc_contour = factor(nuc_contour, levels = unique(nuc_contour)))

ggplot(nuc_contour_by_mode_adj_list) +
  geom_bar(
    mapping = aes(
      x = mode,
      y = (..count..) / sum(..count..),
      fill = nuc_contour
    ),
    show.legend = FALSE,
    colour = "black",
    position = position_dodge2(preserve = "single")
  ) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.28)) +
  facet_grid(cols = vars(nuc_contour)) +
  theme(
    panel.border = element_rect(fill = NA),
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16)
  ) +
  ggtitle("nuclear contours by sentence mode (adjusted)") +
  scale_fill_manual(values = nuc_contour_colours, name = "nuclear contour") +
  labs(x = "Mode", y = "tokens (%)") +
  theme(panel.border = element_rect(fill = NA)) +
  geom_text(aes(
    x = mode,
    y = (..count..) / sum(..count..),
    label = percent((..count..) / sum(..count..), 1)
  ),
  stat = "count",
  vjust = -0.75)

```

#### Chi Squared test of association using adjusted data for nuc_contour

```{r}
with(nuc_contour_by_mode_adj_list,
     table(mode, nuc_contour)) %>% chisq.test %>% print()
```

The overall pattern suggest that L% is more common among YNQs and and DCQs.
However, I don't think that the L% is used to signal a question. I think that, as with the A&H corpus, L% is used when the speaker indicates there is a conflict of expectation of shared knowledge between the speaker and listener. Thus in questions like "You live in the valley?" and "Do you live in the valley?", speaker can use the L% to indicate that the propositional content conflicts with what he or she had previously believed; i.e., it indicates surprise. In a reciprocal manner, in the declaratives of the A&H corpus (and here), the use of an L% indicates that the speaker is indicating surprise that the listener does not already share the knowledge. (i.e. "Where do you live?... "I live in the valley [L%] (and I assumed you already knew that / and you should know that already.") ... Perhaps the best way to think of this is as the surprise~redundancy strategy, with the conflict of expectations expressing redundancy in the declaratives ("This should not be news to you.") and surprise in the questions ("I did not know this at all!").

Bearing in mind that the >H\* L% and H\* L% contours all belong to M8 and may represent transitional code switching, we can re produce the chi squared test without those contours.


```{r}
fin_phon_adj <- m_corpus %>%
  # Count the number of fin_phon by speaker and mode
  group_by(speaker, stim, fin_phon) %>%
  summarise(nuc_count = n(), .groups = "keep") %>%
  pivot_wider(names_from = fin_phon,
              values_from = nuc_count,
              values_fill = 0) %>%
  # convert the totals to proportion per stim.
  adorn_totals("col") %>%
  mutate(across(3:6,  ~  (. / Total))) %>%
  select(-Total) %>%
  # Convert stim column to mode.
  rename(mode = stim) %>%
  mutate(mode = substr(mode, 1, 3)) %>%
  # Convert the values to proportion per mode
  pivot_longer(3:last_col(), "fin_phon") %>%
  group_by(speaker, mode, fin_phon) %>%
  pivot_wider(
    names_from = fin_phon,
    values_from = value,
    values_fill = 0,
    values_fn = ~ sum(.)
  ) %>%
  adorn_totals("col") %>%
  mutate(across(3:6, ~ (. / Total)),
         mode = factor(mode, levels = c("MDC", "MWH", "MYN", "MDQ"))) %>%
  select(-Total) %>%
  as_tibble()

# Create tibble of final boundaries per mode (adjusted).
fin_phon_by_mode_adj <- fin_phon_adj %>%
  # Get the sum of all token proportions per speaker.
  pivot_longer(3:last_col(), "fin_phon") %>%
  select(-c(speaker)) %>% 
  pivot_wider(names_from = fin_phon,
              values_from = value,
              values_fill = 0,
              values_fn = ~ sum(.)
              ) %>% 
  # Convert proportions to an integer based on an ideal total number of tokens.
  mutate(across(2:5, ~ round(. * 15, 0))) %>% 
  arrange(mode) %>% 
  write_csv("fin_phon_by_mode_balanced.csv")

# Create tibble of final boundaries  by gender and mode (adjusted).
fin_phon_by_gender_adj <- fin_phon_adj %>% 
  # Convert gender to speaker
  mutate(speaker = substr(speaker, 1, 1),
         speaker = factor(speaker, levels=unique(speaker))) %>% 
  rename(gender = speaker) %>% 
  # Get the sum of all token proportions per speaker.
  pivot_longer(3:last_col(), "fin_phon") %>%

  pivot_wider(names_from = fin_phon,
              values_from = value,
              values_fill = 0,
              values_fn = ~ sum(.)
              ) %>%
  # Convert proportions to an integer based on an ideal total number of tokens
  # per speaker.
  mutate(across(3:6, ~ if_else(gender=="F",
                               round(. * 15, 0),
                               # project equal number of Male & Female speakers.
                               round(. * 18, 0)
                               )
                )
         ) %>% 
  arrange(mode) %>% 
  write_csv("fin_phon_by_mode_and_gender_adj.csv")

# Make lists of projected boundary tokens.
fin_phon_by_mode_adj_list <- fin_phon_by_mode_adj %>%
  pivot_longer(2:last_col(), "fin_phon") %>%
    uncount(value) %>%
    mutate(fin_phon = factor(fin_phon, levels = unique(fin_phon)))


# Get list of projected boundary tokens by mode and gender.
fin_phon_by_gender_adj_list <- fin_phon_by_gender_adj %>%
    pivot_longer(3:last_col(), "fin_phon") %>%
    uncount(value) %>% 
    mutate(fin_phon = factor(fin_phon, levels = unique(fin_phon)))

```

```{r, fig.height=7, fig.width=15}
ggplot(fin_phon_by_gender_adj_list) +
  geom_bar(
    mapping = aes(
      x = mode,
      y = (..count..) / sum(..count..),
      fill = fin_phon
    ),
    show.legend = FALSE,
    colour = "black",
    position = position_dodge2(preserve = "single")
  ) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.14)) +
  facet_grid(rows = vars(gender), cols = vars(fin_phon)) +
  ggtitle("NFinal boundary by sentence mode and gender (adjusted)") +
  theme(
    panel.border = element_rect(fill = NA),
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16)
  ) +
  ggtitle("Final boundary by sentence mode (adjusted)") +
  scale_fill_manual(values = fin_phon_colours, name = "nuclear contour") +
  labs(x = "Mode", y = "tokens (%)") +
  theme(panel.border = element_rect(fill = NA)) +
  geom_text(aes(
    x = mode,
    y = (..count..) / sum(..count..),
    label = percent((..count..) / sum(..count..), 1)
  ),
  stat = "count",
  vjust = -0.75)

```


```{r fig.height=4, fig.width=10}

ggplot(fin_phon_by_mode_adj_list) +
  geom_bar(
    mapping = aes(
      x = mode,
      y = (..count..) / sum(..count..),
      fill = fin_phon
    ),
    show.legend = FALSE,
    colour = "black",
    position = position_dodge2(preserve = "single")
  ) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.28)) +
  facet_grid(cols = vars(fin_phon)) +
  theme(
    panel.border = element_rect(fill = NA),
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16)
  ) +
  ggtitle("Final boundary by sentence mode (adjusted)") +
  scale_fill_manual(values = fin_phon_colours, name = "final boundary") +
  labs(x = "Mode", y = "tokens (%)") +
  theme(panel.border = element_rect(fill = NA)) +
  geom_text(aes(
    x = mode,
    y = (..count..) / sum(..count..),
    label = percent((..count..) / sum(..count..), 1)
  ),
  stat = "count",
  vjust = -0.75)


```

#### Chi Squared test of association using adjusted data only for H% versus %.

```{r}
with(fin_phon_by_mode_adj_list  %>% 
       filter(fin_phon %in% c("%","H%")) %>% 
       mutate(fin_phon = factor(fin_phon, levels = unique(fin_phon))),
     table(mode, fin_phon)) %>% chisq.test %>% print()

```

However, if we run this again, using only the female data...
```{r}
with(fin_phon_by_gender_adj_list %>% 
       filter(gender == "F") %>% 
       filter(fin_phon %in% c("%","H%")) %>% 
       mutate(fin_phon = factor(fin_phon, levels = unique(fin_phon))),
     table(mode, fin_phon)) %>% chisq.test %>% print()

```

... compared with the male data...

```{r}
with(fin_phon_by_gender_adj_list %>% 
       filter(gender == "M") %>% 
       filter(fin_phon %in% c("%","H%")) %>% 
       mutate(fin_phon = factor(fin_phon, levels = unique(fin_phon))),
     table(mode, fin_phon)) %>% chisq.test() %>% print()

```

The data suggest that there is statistically significant correlation between H% and sentence mode.



#### Chi Squared test of association using adjusted data only for L% versus %.

```{r}
cat("Using Adjusted Data and Montecarlo simulation:\n")
with(fin_phon_by_mode_adj_list  %>% 
       filter(fin_phon %in% c("%","L%")) %>% 
       mutate(fin_phon = factor(fin_phon, levels = unique(fin_phon))),
     table(mode, fin_phon)) %>% chisq.test %>% print()

```

However, if we run this again, using only the female data...
```{r}
with(fin_phon_by_gender_adj_list %>% 
       filter(gender == "F") %>% 
       filter(fin_phon %in% c("%","L%")) %>% 
       mutate(fin_phon = factor(fin_phon, levels = unique(fin_phon))),
     table(mode, fin_phon)) %>% chisq.test %>% print()

```

... compared with the male data...

```{r}
with(fin_phon_by_gender_adj_list %>% 
       filter(gender == "M") %>% 
       filter(fin_phon %in% c("%","L%")) %>% 
       mutate(fin_phon = factor(fin_phon, levels = unique(fin_phon))),
     table(mode, fin_phon)) %>% chisq.test %>% print()

```
The results give the impression that this is a feature of male rather than female speech. However, only three out of the five male speakers do this, so it is unlikely to be a features of "male speech". More likely, different speakers interpreted the motivation behind the prompt statement and their response, in terms of the intonational phonology, reflects whether or not they chose to use a surprise/redundancy falling boundary.


#### GLMM test of difference between nuc_contour as a fn of mode.
```{r fig.height=3, fig.width=9, warning = FALSE, message = FALSE, tidy = TRUE}

nuc_contour_model <- glmer(
  nuc_contour ~ mode + gender + (1 | speaker),
  data = m_corpus,
  family = binomial(link = "logit"),
  # change optimizer to avoid convergence errors
  control = glmerControl(
    optimizer = "optimx",
    calc.derivs = FALSE,
    optCtrl = list(
      method = "nlminb",
      starttests = FALSE,
      kkt = FALSE
    )
  )
)

nuc_contour_model_null = 
  cur_model <- glmer(
  nuc_contour ~ 1 + (1 | speaker),
  data = m_corpus,
  family = binomial(link = "logit"),
  # change optimizer to avoid convergence errors
  control = glmerControl(
    optimizer = "optimx",
    calc.derivs = FALSE,
    optCtrl = list(
      method = "nlminb",
      starttests = FALSE,
      kkt = FALSE
    )
  )
)

summary(nuc_contour_model)

anova(nuc_contour_model, nuc_contour_model_null, test="Chisq") %>%
  formattable(
    caption="ANOVA of model and null model, assuming no register tier."
    )

cat("isSingular(nuc_contour_model) =", isSingular(nuc_contour_model))

x <- printTidyModel(nuc_contour_model,
                    write_r2="Mode_PA_Mode_PA_No_Reg_GLMM",
                    is_GLM = TRUE
                    )


x$r2
x$table
```


## Intercepts and Pairwise comparisons
```{r echo=FALSE, paged.print=FALSE}

charts <- getModelFixedFX(
  my_equation =  nuc_contour ~ mode + gender + (1 | speaker),
  my_data = m_corpus,
  write="Mode_PA_Mode_PA_No_Reg_GLMM",
  is_GLM=TRUE,
  extra_text = ", assuming no register tier."
)

charts$intercepts
charts$pairwise


```
