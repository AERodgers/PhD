---
title: 'Chapter 07: Analysis of Function'
subtitle: 'Sentence Mode and Nuclear Contour Phonology without Reg Tier'
output:
  html_document: default
  word_document: default
  pdf_document: default
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE)


# Load Functions.
source("../../functions/myFunctions.R") 

# Load packages.
installMissingPackages(
  c(
    # Include statistical packages.
    "lmerTest",
    "lme4",
    "optimx",
    "MuMIn",
    
    # Include packages for tidy output.
    "broomExtra",
    "formattable",
    "janitor",
    "knitr",
    "RColorBrewer",
    "sjPlot",
    "tidyverse",
    
    # Include packages for %in% %notin% syntactic notation
    "mefa4"
  )
)

# Set themes and colour schemes.
theme_set(theme_minimal(base_size = 10))

# Change this as required
options("speakr.praat.path" = "C:/Program Files/Praat/Praat.exe")

## set colours
p_color <- all_models_tidy ~ style(color =
                                     if_else(as.double(all_models_tidy) < 0.05,
                                             "green",
                                             "red")
                                   )
nuc_contour_colours <- c(
  "L*H %"   = brewer.pal(6, "Set2")[3],
  "L*H L%" = brewer.pal(8, "Set2")[7],
  ">H* L%"  = brewer.pal(6, "Set2")[4],
  "H* L%"   = brewer.pal(6, "Set2")[5],
  "L*H H%" = brewer.pal(6, "Set2")[2],
  "L*H HL%" = brewer.pal(8, "Set2")[8]
)

fin_phon_colours <- c(
  "%"   = brewer.pal(6, "Set2")[3],
  "L%" = brewer.pal(8, "Set2")[7],
  "H%" = brewer.pal(6, "Set2")[2],
  "HL%" = brewer.pal(8, "Set2")[8]
)
```


```{r Load and prepare m corpus}
# Get  Data.
m_corpus <- get_m_corpus("../data/m_corpus.csv")  %>%
  mutate(
      # Remove L% in [..H L%] due to marginal salience. 
      nuc_contour = if_else(
        nuc_contour == "^[L*H %]" | nuc_contour == "^[L*H L%]",
        "^[L*H] %",
        if_else(nuc_contour == "L*^[H L%]", "L*^[H] %", nuc_contour)),
    # replace L*^[H] % with L*H H% and L*^[H] L% with L*H HL%
    fin_phon = if_else(
      acc_phon == "L*^[H]" & fin_phon != "L%",
      "H%",
      if_else(acc_phon == "L*^[H]" & fin_phon == "L%", "HL%", fin_phon)
    ),
    acc_phon = if_else(
      acc_phon == "L*^[H]" & (fin_phon == "H%" | fin_phon == "HL%"),
      "L*H",
      acc_phon
    ),
    nuc_contour = paste(acc_phon, fin_phon, sep = " "),
    # remove non-accentuation from phr_phon
    phr_phon = str_replace_all(phr_phon, "\\(\\*\\)", ""),
    # replace L*^[H] with L*H H(L)%
    phr_phon = str_replace(phr_phon, "L\\*\\^\\[H\\] %", "L\\*H H%"),
    phr_phon = str_replace(phr_phon, "L\\*\\^\\[H\\] L%", "L\\*H HL%"),
    # remove register tier
    across(
      c("phr_phon", "acc_phon", "nuc_contour", "fin_phon"),
      ~ str_replace_all(., "\\^|\\[|\\]", "")
    ),
    across(
      c("phr_phon", "acc_phon", "nuc_contour", "fin_phon"),
      ~ factor(.,
               levels = unique(.))
    )
  ) %>%
  # Select only columns for analysis
  select(speaker,
         gender,
         mode,
         prompt,
         stim,
         phr_phon,
         nuc_contour,
         acc_phon,
         fin_phon)

```

### Nuclear contour

It is clear that there is little relationship between the pitch accent and mode when the register tier is discounted. However, looking at the raw data for the phrase-level phonology, it looks like L% boundaries are more commonly associated with questions than declaratives.

Therefore, it might be worth looking at the nuclear contour as a whole in this data set.

    
```{r adjusted tables for nuclear contours per speaker}
# Create tibble summarising nuclear contours per mode per speaker
nuc_contour_adj <- m_corpus %>%
  # Count the number of nuc_contour by speaker and mode
  group_by(speaker, stim, nuc_contour) %>%
  summarise(nuc_count = n(), .groups = "keep") %>%
  pivot_wider(names_from = nuc_contour,
              values_from = nuc_count,
              values_fill = 0) %>%
  # convert the totals to proportion per stim.
  adorn_totals("col") %>%
  mutate(across(3:6,  ~  (. / Total))) %>%
  select(-Total) %>%
  # Convert stim column to mode.
  rename(mode = stim) %>%
  mutate(mode = substr(mode, 1, 3)) %>%
  # Convert the values to proportion per mode
  pivot_longer(3:last_col(), "nuc_contour") %>%
  group_by(speaker, mode, nuc_contour) %>%
  pivot_wider(
    names_from = nuc_contour,
    values_from = value,
    values_fill = 0,
    values_fn = ~ sum(.)
  ) %>%
  adorn_totals("col") %>%
  mutate(across(3:6, ~ (. / Total)),
         mode = factor(mode, levels = c("MDC", "MWH", "MYN", "MDQ"))) %>%
  select(-Total) %>%
  as_tibble()

# Create tibble of nuclear contours per speaker (adjusted).
nuc_contour_by_speaker_adj <- nuc_contour_adj %>%
  # Get the sum of all token proportions per speaker.
  pivot_longer(3:last_col(), "nuc_contour") %>%
  select(-c(mode)) %>% 
  pivot_wider(names_from = nuc_contour,
              values_from = value,
              values_fill = 0,
              values_fn = ~ sum(.)
              ) %>%
  # Convert proportions to an integer based on an ideal total number of tokens
  # per speaker.
  mutate(across(2:5, ~ round(. * 15, 0))) %>% 
  write_csv("nuc_contour_by_speaker_adj.csv")

# Create tibble of nuclear contours per mode (adjusted).
nuc_contour_by_mode_adj <- nuc_contour_adj %>%
  # Get the sum of all token proportions per speaker.
  pivot_longer(3:last_col(), "nuc_contour") %>%
  select(-c(speaker)) %>% 
  pivot_wider(names_from = nuc_contour,
              values_from = value,
              values_fill = 0,
              values_fn = ~ sum(.)
              ) %>% 
  # Convert proportions to an integer based on an ideal total number of tokens.
  mutate(across(2:5, ~ round(. * 15, 0))) %>% 
  arrange(mode) %>% 
  write_csv("nuc_contour_by_mode_balanced.csv")

# Create tibble of nuclear contours by gender and mode (adjusted).
nuc_contour_by_gender_adj <- nuc_contour_adj %>% 
  # Convert gender to speaker
  mutate(speaker = substr(speaker, 1, 1),
         speaker = factor(speaker, levels=unique(speaker))) %>% 
  rename(gender = speaker) %>% 
  # Get the sum of all token proportions per speaker.
  pivot_longer(3:last_col(), "nuc_contour") %>%

  pivot_wider(names_from = nuc_contour,
              values_from = value,
              values_fill = 0,
              values_fn = ~ sum(.)
              ) %>%
  # Convert proportions to an integer based on an ideal total number of tokens
  # per speaker.
  mutate(across(3:6, ~ if_else(gender=="F",
                               round(. * 15, 0),
                               # project equal number of Male & Female speakers.
                               round(. * 18, 0)
                               )
                )
         ) %>% 
  arrange(mode) %>% 
  write_csv("nuc_contour_by_mode_and_gender_adj.csv")

```

#### Nuclear contour by Speaker
```{r warning=FALSE}
nuc_contour_by_speaker_adj %>%
  write_csv("nuc_by_speaker_adj.csv")  %>%
  rename_all(list(~str_replace_all(., "([\\*\\[\\^\\>])", "\\\\\\1"))) %>%  
  adorn_totals(where = "row") %>% 
  formattable(
    caption="Distibution by speaker of nuclear contours in M-corpus (adjusted)",
    align="r",
    list(area(col = 2:6, row=1:nrow(.)-1) ~ proportion_bar(color = c(
      rep(brewer.pal(8, "Pastel2")[3], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[7], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[2], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[4], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[5], nrow(.)-1)
      )))
    )
```


```{r plot adjusts nuc countours per speaker, fig.width = 5, fig.height = 2.5}
# Percentage Stacked bar
ggplot(data = nuc_contour_by_speaker_adj_uncount %>%
         # Uncount table for bar chart
         nuc_contour_by_speaker_adj %>%
         gather("nuc_contour", "count", -c(speaker)) %>%
         uncount(count) %>%
         #arrange levels
         mutate(nuc_contour = factor(
           nuc_contour,
           levels =
             c("L*H H%", "L*H HL%", "L*H L%", "H* L%",  ">H* L%", "L*H %"))),
       aes(fill = nuc_contour, x = speaker)) +
  geom_bar(stat = "count",
           position = "fill",
           width = 0.30,
           colour = "black") +
  scale_fill_manual(values = nuc_contour_colours) +
  labs(y = "Proportion of nuclear contours",
       x = "Speaker") +
  theme(panel.border = element_rect(fill = NA)) +
  scale_y_continuous(sec.axis = sec_axis(~ . * 3 + 4))
```

#### Nuclear contour by Sentence Mode

```{r table of adjusted distribution of nuc contours by mode}
# Calculate a projected balanced number of tokens for each PA as a function of # sentence mode.
#
# This takes into consideration the number of utterances per speaker per stimulus and the number of speakers per stimulus.

nuc_contour_by_mode_adj %>%
  rename_all(list( ~ str_replace_all(., "([\\*\\[\\^\\>])", "\\\\\\1"))) %>%
  adorn_totals("row") %>%
  formattable(caption =
                "Distibution by mode of nuclear contours in M-corpus (adjusted)",
    list(area(col = 2:7, row=1:nrow(.)-1) ~ proportion_bar(color = c(
      rep(brewer.pal(8, "Pastel2")[3], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[7], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[2], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[8], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[4], nrow(.)-1),
      rep(brewer.pal(8, "Pastel2")[5], nrow(.)-1)
      )))
  )

```

```{r plot adjusted distrubition of contours by mode and gender, fig.width = 14, fig.height=5, results="asis"}
ggplot(
  nuc_contour_by_gender_adj %>%
    # uncount date for chart
    pivot_longer(3:last_col(), "nuc_contour") %>%
    uncount(value) %>%
    mutate(nuc_contour = factor(nuc_contour, levels = unique(nuc_contour)))
  ) +
  geom_bar(mapping = aes(x = mode,
                         y = (..count..) / sum(..count..),
                         fill = nuc_contour),
           show.legend = FALSE,
           colour = "black",
           position = position_dodge2(preserve = "single")) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.14)) +
  facet_grid(rows = vars(gender), cols = vars(nuc_contour)) +
  ggtitle("Nuclear contours by sentence mode and gender (adjusted)") +
  theme(
    panel.border = element_rect(fill = NA),
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16)
  ) +
  ggtitle("nuclear contours by sentence mode (adjusted)") +
  scale_fill_manual(values = nuc_contour_colours, name = "nuclear contour") +
  labs(x = "Mode", y = "tokens (%)") +
  theme(panel.border = element_rect(fill = NA)) +
  geom_text(aes(
    x = mode,
    y = (..count..) / sum(..count..),
    label = percent((..count..) / sum(..count..), 1)
  ),
  stat = "count",
  vjust = -0.75)

```

It appears that the male speakers are more likely to begin using L% across the question mode hierarchy more than the female speakers. There are not enough speakers, I believe, however, to justify this as a general conclusion, especially as it is only M8, M9, and M10 who do this.

```{r plot adjusted distrubition of contours by mode, fig.width = 14, fig.height = 3, results="asis"}
ggplot(
  nuc_contour_by_mode_adj %>%
    # Uncount table for bar chart.
    pivot_longer(2:last_col(), "nuc_contour") %>%
    uncount(value) %>%
    mutate(nuc_contour = factor(nuc_contour, levels = unique(nuc_contour)))
  ) +
  geom_bar(mapping = aes(x = mode,
                         y = (..count..) / sum(..count..),
                         fill = nuc_contour),
           show.legend = FALSE,
           colour = "black",
           position = position_dodge2(preserve = "single")) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.28)) +
  facet_grid(cols = vars(nuc_contour)) +
  theme(panel.border = element_rect(fill = NA),
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 16)) +
  ggtitle("nuclear contours by sentence mode (adjusted)") +
  scale_fill_manual(values = nuc_contour_colours, name = "nuclear contour") +
  labs(x = "Mode", y = "tokens (%)") +
  theme(panel.border = element_rect(fill = NA)) +
  geom_text(aes(x = mode,
                y = (..count..) / sum(..count..),
                label = percent((..count..) / sum(..count..), 1)
                ),
            stat = "count",
            vjust = -0.75)

```

The overall pattern suggest that L% is more common among YNQs and and DCQs.
However, I don't think that the L% is used to signal a question. I think that, as with the A&H corpus, L% is used when the speaker indicates there is a conflict of expectation of shared knowledge between the speaker and listener. Thus in questions like "You live in the valley?" and "Do you live in the valley?", speaker can use the L% to indicate that the propositional content conflicts with what he or she had previously believed; i.e., it indicates surprise. In a reciprocal manner, in the declaratives of the A&H corpus (and here), the use of an L% indicates that the speaker is indicating surprise that the listener does not already share the knowledge. (i.e. "Where do you live?... "I live in the valley [L%] (and I assumed you already knew that / and you should know that already.") ... Perhaps the best way to think of this is as the surprise~redundancy strategy, with the conflict of expectations expressing redundancy in the declaratives ("This should not be news to you.") and surprise in the questions ("I did not know this at all!").


```{r}
fin_phon_adj <- m_corpus %>%
  # Count the number of fin_phon by speaker and mode
  group_by(speaker, stim, fin_phon) %>%
  summarise(nuc_count = n(), .groups = "keep") %>%
  pivot_wider(names_from = fin_phon,
              values_from = nuc_count,
              values_fill = 0) %>%
  # convert the totals to proportion per stim.
  adorn_totals("col") %>%
  mutate(across(3:6,  ~  (. / Total))) %>%
  select(-Total) %>%
  # Convert stim column to mode.
  rename(mode = stim) %>%
  mutate(mode = substr(mode, 1, 3)) %>%
  # Convert the values to proportion per mode
  pivot_longer(3:last_col(), "fin_phon") %>%
  group_by(speaker, mode, fin_phon) %>%
  pivot_wider(
    names_from = fin_phon,
    values_from = value,
    values_fill = 0,
    values_fn = ~ sum(.)
  ) %>%
  adorn_totals("col") %>%
  mutate(across(3:6, ~ (. / Total)),
         mode = factor(mode, levels = c("MDC", "MWH", "MYN", "MDQ"))) %>%
  select(-Total) %>%
  as_tibble()

# Create tibble of final boundaries per mode (adjusted).
fin_phon_by_mode_adj <- fin_phon_adj %>%
  # Get the sum of all token proportions per speaker.
  pivot_longer(3:last_col(), "fin_phon") %>%
  select(-c(speaker)) %>% 
  pivot_wider(names_from = fin_phon,
              values_from = value,
              values_fill = 0,
              values_fn = ~ sum(.)
              ) %>% 
  # Convert proportions to an integer based on an ideal total number of tokens.
  mutate(across(2:5, ~ round(. * 15, 0))) %>% 
  arrange(mode) %>% 
  write_csv("fin_phon_by_mode_balanced.csv")

# Create tibble of final boundaries  by gender and mode (adjusted).
fin_phon_by_gender_adj <- fin_phon_adj %>% 
  # Convert gender to speaker
  mutate(speaker = substr(speaker, 1, 1),
         speaker = factor(speaker, levels=unique(speaker))) %>% 
  rename(gender = speaker) %>% 
  # Get the sum of all token proportions per speaker.
  pivot_longer(3:last_col(), "fin_phon") %>%

  pivot_wider(names_from = fin_phon,
              values_from = value,
              values_fill = 0,
              values_fn = ~ sum(.)
              ) %>%
  # Convert proportions to an integer based on an ideal total number of tokens
  # per speaker.
  mutate(across(3:6, ~ if_else(gender=="F",
                               round(. * 15, 0),
                               # project equal number of Male & Female speakers.
                               round(. * 18, 0)
                               )
                )
         ) %>% 
  arrange(mode) %>% 
  write_csv("fin_phon_by_mode_and_gender_adj.csv")

# Make lists of projected boundary tokens.
fin_phon_by_mode_adj_list <- fin_phon_by_mode_adj %>%
  pivot_longer(2:last_col(), "fin_phon") %>%
    uncount(value) %>%
    mutate(fin_phon = factor(fin_phon, levels = unique(fin_phon)))


# Get list of projected boundary tokens by mode and gender.
fin_phon_by_gender_adj_list <- fin_phon_by_gender_adj %>%
    pivot_longer(3:last_col(), "fin_phon") %>%
    uncount(value) %>% 
    mutate(fin_phon = factor(fin_phon, levels = unique(fin_phon)))

```

```{r, fig.width = 10, fig.height = 5}
ggplot(fin_phon_by_gender_adj_list) +
  geom_bar(
    mapping = aes(
      x = mode,
      y = (..count..) / sum(..count..),
      fill = fin_phon
    ),
    show.legend = FALSE,
    colour = "black",
    position = position_dodge2(preserve = "single")
  ) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.14)) +
  facet_grid(rows = vars(gender), cols = vars(fin_phon)) +
  ggtitle("NFinal boundary by sentence mode and gender (adjusted)") +
  theme(
    panel.border = element_rect(fill = NA),
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16)
  ) +
  ggtitle("Final boundary by sentence mode (adjusted)") +
  scale_fill_manual(values = fin_phon_colours, name = "nuclear contour") +
  labs(x = "Mode", y = "tokens (%)") +
  theme(panel.border = element_rect(fill = NA)) +
  geom_text(aes(
    x = mode,
    y = (..count..) / sum(..count..),
    label = percent((..count..) / sum(..count..), 1)
  ),
  stat = "count",
  vjust = -0.75)

```


```{r fig.height=3, fig.width=10}

ggplot(fin_phon_by_mode_adj_list) +
  geom_bar(
    mapping = aes(
      x = mode,
      y = (..count..) / sum(..count..),
      fill = fin_phon
    ),
    show.legend = FALSE,
    colour = "black",
    position = position_dodge2(preserve = "single")
  ) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.28)) +
  facet_grid(cols = vars(fin_phon)) +
  theme(
    panel.border = element_rect(fill = NA),
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16)
  ) +
  ggtitle("Final boundary by sentence mode (adjusted)") +
  scale_fill_manual(values = fin_phon_colours, name = "final boundary") +
  labs(x = "Mode", y = "tokens (%)") +
  theme(panel.border = element_rect(fill = NA)) +
  geom_text(aes(
    x = mode,
    y = (..count..) / sum(..count..),
    label = percent((..count..) / sum(..count..), 1)
  ),
  stat = "count",
  vjust = -0.75)


```



DO MODE AND FIN PHON!!!!

The results give the impression that this is a feature of male rather than female speech. However, only three out of the five male speakers do this, so it is unlikely to be a features of "male speech". More likely, different speakers interpreted the motivation behind the prompt statement and their response, in terms of the intonational phonology, reflects whether or not they chose to use a surprise/redundancy falling boundary.


#### GLMM test of difference between nuc_contour as a fn of mode.
```{r GLMM Test}
nuc_contour_model <- glmer(
  nuc_contour ~ mode + (1 | speaker),
  data = m_corpus,
  family = binomial(link = "logit"),
  # change optimizer to avoid convergence errors
  control = glmerControl(
    optimizer = "optimx",
    calc.derivs = FALSE,
    optCtrl = list(
      method = "nlminb",
      starttests = FALSE,
      kkt = FALSE
    )
  )
)

nuc_contour_model_null = 
  cur_model <- glmer(
  nuc_contour ~ 1 + (1 | speaker),
  data = m_corpus,
  family = binomial(link = "logit"),
  # change optimizer to avoid convergence errors
  control = glmerControl(
    optimizer = "optimx",
    calc.derivs = FALSE,
    optCtrl = list(
      method = "nlminb",
      starttests = FALSE,
      kkt = FALSE
    )
  )
)

summary(nuc_contour_model)
```


```{r GLMM Test Figures and Charts, fig.width = 4.2, fig.height = 2.5, results="asis"}
cat(
  "isSingular(nuc_contour_model, tol=1e-5) -->",
  isSingular(nuc_contour_model, tol = 1e-5),
  "\n"
)

anova(nuc_contour_model, nuc_contour_model_null, test="Chisq") %>%
  formattable(
    caption="ANOVA of model and null model, assuming no register tier."
    )

x <- printTidyModel(nuc_contour_model,
                    write_r2="Mode_PA_Mode_PA_No_Reg_GLMM",
                    is_GLM = TRUE,
                    transform="exp",
                    show.intercept=TRUE,
                    type="pred"
                    )


x$r2
x$table

charts <- getModelFixedFX(
  my_equation =  nuc_contour ~ mode + (1 | speaker),
  my_data = m_corpus,
  write="Mode_PA_Mode_PA_No_Reg_GLMM",
  is_GLM=TRUE,
  extra_text = ", assuming no register tier."
)

charts$intercepts
charts$pairwise


```
