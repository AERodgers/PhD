---
title: 'Chapter 07: Analysis of Function: Sentence Modes'
subtitle: 'Nuclear Phonology and Mode'
output:
  html_document: default
  word_document: default
  pdf_document: default
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE)


# Load Functions.
source("../../functions/myFunctions.R") 

# Load packages.
installMissingPackages(
  c(
    # Load tidy packages.
    "formattable",
    "janitor",
    "kableExtra",
    "RColorBrewer",
    "tidyverse",
    # Load stats package.
    "lme4"
  )
)

# Set themes and colour schemes.
theme_set(theme_minimal(base_size = 10))

```


## Nuclear Pitch Accent data (raw data)

### Nuclear Pitch Accent by Speaker

```{r summarise PA by speaker, warning=FALSE}
# Create summary table of Pitch Accent by Speaker.


m_corpus %>%
  group_by(speaker, acc_phon) %>%
  summarise(acc_count = n(), .groups = "keep") %>%
  pivot_wider(names_from = acc_phon,
              values_from = acc_count,
              values_fill = 0) %>%
  select("speaker", "H*", "L*H", "^[L*]H", ">H*", "L*^[H]", "^[L*H]")  %>% 
  write_csv("nuc_by_speaker_raw.csv") %>%
  rename_all(list(~str_replace_all(., "([\\*\\[\\^\\>])", "\\\\\\1"))) %>%  
  adorn_totals(where = "row") %>% 
  formattable(
    caption =
      "Distibution by speaker of nuclear pitch accents in M-corpus (raw)",
    list(area(col = 2:7, row= 1:nrow(.)-1) ~ proportion_bar(color = c(
      rep(brewer.pal(6, "Pastel2")[5], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[3], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[6], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[4], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[2], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[1], nrow(.)-1)
      )))
    )

```


# **Adjusted Data**

The raw data is unbalanced since the number of utterances per target speaker varies slightly. For some speakers, there are no repetitions of some target utterances. Therefore, the data has been adjusted to project an estimated balanced number of tokens per speaker per target utterance.

Firstly a tibble is created summarising the proportion of pitch accents per mode per speaker. This is done in three initial stages:

  1. Count the number of phonological tokens per stimulus per speaker.
  2. Convert the counts to proportion per stimulus per speaker.
  3. Convert the proportion per stimulus per speaker to a proportion per stimulus per mode.

From this table summary tables are created:

  1. pitch accents per speaker (adjusted)

      a. Calculate the sum all proportions per token per speaker.
      b. Convert proportions to an integer based on an ideal total number of tokens per speaker.

  2. pitch accents per mode (adjusted):

      a. Calculate the sum all proportions per token per mode.
      b. Convert proportions to an integer based on an ideal total number of tokens per mode
      
  3. pitch accents by gender and mode (adjusted):

      a. Calculate the sum all proportions per token by mode and gender.
      b. Convert proportions to an integer based on an ideal total number of tokens per mode as if there were an equal numnber of male and female participants.

```{r warning=FALSE}
# Create tibble summarising  proportion of pitch accents per mode per speaker
pa_adj <- m_corpus %>%
    # Count the number of acc_phon by speaker and mode
    group_by(speaker, stim, acc_phon) %>%
    summarise(nuc_count = n(), .groups = "keep") %>%
    pivot_wider(names_from=acc_phon, values_from=nuc_count, values_fill = 0) %>%
    # convert the totals to proportion per stim.
    adorn_totals("col") %>% 
    mutate(across(3:8,  ~  (. / Total))) %>%
    select(-Total) %>% 
    # Convert stim column to mode.
    rename(mode = stim) %>% 
    mutate(mode = substr(mode, 1, 3)) %>%
    # Convert the values to proportion per mode
    pivot_longer(3:last_col(), "acc_phon") %>% 
    group_by(speaker, mode, acc_phon) %>%
    pivot_wider(names_from=acc_phon,
                values_from=value,
                values_fill = 0,
                values_fn = ~sum(.)) %>%
    adorn_totals("col") %>% 
    mutate(across(3:8, ~ (. / Total)),
           mode = factor(mode, levels = c("MDC", "MWH", "MYN", "MDQ"))
           ) %>%
    select(-Total) %>%
    as_tibble()

# Create tibble of pitch accents per speaker (adjusted).
pa_by_speaker_adj <- pa_adj %>%
  # Get the sum of all token proportions per speaker.
  pivot_longer(3:last_col(), "acc_phon") %>%
  select(-mode) %>% 
  pivot_wider(names_from = acc_phon,
              values_from = value,
              values_fill = 0,
              values_fn = ~ sum(.)
              ) %>%
  # Convert proportions to an integer based on an ideal total number of tokens
  # per speaker.
  mutate(across(2:7, ~ round(. * 15, 0))) %>% 
  select("speaker", "H*", "L*H", "^[L*]H", ">H*", "L*^[H]", "^[L*H]") %>% 
  write_csv("nucs_by_speaker_adj.csv")

# Create tibble of pitch accents per mode (adjusted).
pa_by_mode_adj <- pa_adj %>%
  # Get the sum of all token proportions per speaker.
  pivot_longer(3:last_col(), "acc_phon") %>%
  select(-speaker) %>% 
  pivot_wider(names_from = acc_phon,
              values_from = value,
              values_fill = 0,
              values_fn = ~ sum(.)
              ) %>% 
  # Convert proportions to an integer based on an ideal total number of tokens.
  mutate(across(2:7, ~ round(. * 15, 0))) %>% 
  select("mode", "H*", "L*H", "^[L*]H", ">H*", "L*^[H]", "^[L*H]") %>% 
  arrange(mode) %>% 
  write_csv("modes_nuc_balanced.csv")

# Create tibble of pitch accents by gender and mode (adjusted).
pa_by_gender_adj <- pa_adj %>%
  # Convert gender to speaker
  mutate(speaker = substr(speaker, 1, 1),
         speaker = factor(speaker, levels=unique(speaker))) %>% 
  rename(gender = speaker) %>% 
  # Get the sum of all token proportions per speaker.
  pivot_longer(3:last_col(), "acc_phon") %>%
  pivot_wider(names_from = acc_phon,
              values_from = value,
              values_fill = 0,
              values_fn = ~ sum(.)
              ) %>%
  # Convert proportions to an integer based on an ideal total number of tokens
  # per speaker.
  mutate(across(3:8, ~ if_else(gender=="F",
                               round(. * 15, 0),
                               # project equal number of Male & Female speakers.
                               round(. * 18, 0)
                               )
                )
         ) %>% 
  select("mode", "gender", "H*", "L*H", "^[L*]H", ">H*", "L*^[H]", "^[L*H]") %>% 
  arrange(mode) %>% 
  write_csv("modes_nuc_gender_adj.csv")

```

## Nuclear Pitch accent (adjusted data)

### Nuclear Pitch Accent by Speaker

```{r warning=FALSE}
pa_by_speaker_adj %>%
  write_csv("nuc_by_speaker_adj.csv")  %>%
  rename_all(list(~str_replace_all(., "([\\*\\[\\^\\>])", "\\\\\\1"))) %>%  
  adorn_totals(where = "row") %>% 
  formattable(
    caption="Distibution by speaker of nuclear pitch accents in M-corpus (adjusted)",
    list(area(col = 2:7, row=1:nrow(.)-1) ~ proportion_bar(color = c(
      rep(brewer.pal(6, "Pastel2")[5], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[3], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[6], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[4], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[2], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[1], nrow(.)-1)
      )))
    )
```

```{r warning=FALSE}
pa_by_speaker_adj_uncount <- pa_by_speaker_adj %>%
    gather("acc_phon", "count",-c(speaker)) %>%
    uncount(count)

```

```{r warning=TRUE, fig.width = 10, fig.height = 4}
# Percentage Stacked bar

ggplot(data = pa_by_speaker_adj_uncount,
       aes(fill = acc_phon, x = speaker)) +
    geom_bar(
        stat = "count",
        position = "fill",
        width = 0.30,
        colour = "black"
    ) +
    scale_fill_manual(values = pitch_accent_colours[1:6]) +
    
    labs(y = "Proportion of Pitch Accents",
         x = "Speaker") +
    theme(panel.border = element_rect(fill = NA)) +
    scale_y_continuous(sec.axis = sec_axis( ~ . * 3 + 4))
```

### Nuclear Pitch Accent by Sentence Mode

```{r warning=FALSE}
# Calculate a projected balanced number of tokens for each PA as a function of # sentence mode.
#
# This takes into consideration the number of utterances per speaker per stimulus and the number of speakers per stimulus.

 pa_by_mode_adj %>%
  rename_all(list(~str_replace_all(., "([\\*\\[\\^\\>])", "\\\\\\1"))) %>%  
  adorn_totals("row") %>% 
  formattable(
    caption=
      "Distibution by mode of nuclear pitch accents in M-corpus (adjusted)",
    list(area(col=2:7, row=1:4) ~ proportion_bar(color = c(
      rep(brewer.pal(6, "Pastel2")[5], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[3], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[6], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[4], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[2], nrow(.)-1),
      rep(brewer.pal(6, "Pastel2")[1], nrow(.)-1)
      )))
    )
```

```{r warning=FALSE}
pa_by_mode_adj %>%
  select("mode", "L*H", "L*^[H]", "^[L*H]") %>%
  rename_all(list(~str_replace_all(., "([\\*\\[\\^\\>])", "\\\\\\1"))) %>%
  adorn_totals("row") %>% 
  formattable(
    caption = paste("Distibution by of pitch accents by mode in M-corpus",
                    "(adjusted, outliers excluded)"),
    list(area(col=2:4, row=1:nrow(.)-1) ~ proportion_bar(color = c(

      rep(brewer.pal(6, "Pastel2")[3], 4),

      rep(brewer.pal(6, "Pastel2")[2], 4),
      rep(brewer.pal(6, "Pastel2")[1], 4)
      )))
    )

```

```{r warning=FALSE}

# Get list of projected PA tokens by mode and gender.
pa_by_gender_adj_list <- pa_by_gender_adj %>%
    pivot_longer(3:last_col(), "acc_phon") %>%
    uncount(value) %>% 
    mutate(acc_phon = factor(acc_phon, levels = c("H*", "L*H", "^[L*]H", ">H*", "L*^[H]", "^[L*H]")))

```

```{r, fig.height=7, fig.width=10}
ggplot(pa_by_gender_adj_list %>%
         filter(acc_phon %notin% (c("H*", ">H*", "^[L*]H")))) +
  geom_bar(
    mapping = aes(
      x = mode,
      y = (..count..) / sum(..count..),
      fill = acc_phon
    ),
    show.legend = FALSE,
    colour = "black",
    position = position_dodge2(preserve = "single")
  ) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.14)) +
  facet_grid(rows = vars(gender), cols = vars(acc_phon)) +
  ggtitle("Nuclear pitch accents by sentence mode and gender (adjusted)") +
  theme(
    panel.border = element_rect(fill = NA),
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16)
  ) +
  ggtitle("Nuclear pitch accents by sentence mode (adjusted)") +
  scale_fill_manual(values = pitch_accent_colours, name = "Pitch Accent") +
  labs(x = "Mode", y = "tokens (%)") +
  theme(panel.border = element_rect(fill = NA)) +
  geom_text(aes(
    x = mode,
    y = (..count..) / sum(..count..),
    label = percent((..count..) / sum(..count..), 1)
  ),
  stat = "count",
  vjust = -0.75)

```

```{r fig.height=4, fig.width=9.5}
pa_by_mode_adj_list <- pa_by_mode_adj %>% 
  pivot_longer(2:last_col(), "acc_phon") %>%
    uncount(value)

ggplot(pa_by_mode_adj_list %>%
         filter(acc_phon %notin% c("H*", ">H*", "^[L*]H")) %>%
         mutate(acc_phon = factor(acc_phon,
                                  levels = c("L*H", "L*^[H]", "^[L*H]")
                  ))
       ) +
  geom_bar(
    mapping = aes(
      x = mode,
      y = (..count..) / sum(..count..),
      fill = acc_phon
    ),
    show.legend = FALSE,
    colour = "black",
    position = position_dodge2(preserve = "single")
  ) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.28)) +
  facet_grid(cols = vars(acc_phon)) +
  theme(
    panel.border = element_rect(fill = NA),
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16)
  ) +
  ggtitle("Nuclear pitch accents by sentence mode (adjusted)") +
  scale_fill_manual(values = pitch_accent_colours, name = "Pitch Accent") +
  labs(x = "Mode", y = "tokens (%)") +
  theme(panel.border = element_rect(fill = NA)) +
  geom_text(aes(
    x = mode,
    y = (..count..) / sum(..count..),
    label = percent((..count..) / sum(..count..), 1)
  ),
  stat = "count",
  vjust = -0.75)

```




```{r load and process corpus, include=FALSE}
# Get  Data.
m_corpus <- get_m_corpus("../data/m_corpus.csv")  %>%
  # Consolidate nuc_contour based on observation and types of register shift.
  mutate(
    nuc_contour =
      if_else(
        nuc_contour == "^[L*H %]" | nuc_contour == "^[L*H L%]",
        "^[L*H] %",
        if_else(nuc_contour == "L*^[H L%]", "L*^[H] %", nuc_contour)
      ),
    acc_phon = factor(str_replace(nuc_contour, "\\s%$|\\sL%$", ""),
                      levels = c("H*", "L*H", "^[L*]H", ">H*", "L*^[H]", "^[L*H]")),
    acc_phon = factor(acc_phon, levels = unique(acc_phon)
      )
  ) %>%
  # Select only columns for analysis
  select(speaker,
         gender,
         mode,
         acc_phon)


```

#### GLMM test of difference between acc_phon as a fn of mode.

* models with random slopes generate singularity issues.
```{r model test, tidy = TRUE}
acc_phon_model <- glmer(
  acc_phon ~ mode + (1 | speaker),
  data = m_corpus,
  family = binomial(link = "logit"),
  # change optimizer to avoid convergence errors
  control = glmerControl(
    optimizer = "optimx",
    calc.derivs = FALSE,
    optCtrl = list(
      method = "nlminb",
      starttests = FALSE,
      kkt = FALSE
    )
  )
)

acc_phon_model_null = 
  cur_model <- glmer(
  acc_phon ~ 1 + (1 | speaker),
  data = m_corpus,
  family = binomial(link = "logit"),
  # change optimizer to avoid convergence errors
  control = glmerControl(
    optimizer = "optimx",
    calc.derivs = FALSE,
    optCtrl = list(
      method = "nlminb",
      starttests = FALSE,
      kkt = FALSE
    )
  )
)

summary(acc_phon_model)
```


```{r model results, fig.width = 4.2, fig.height = 2.5, results="asis"}
cat(
  "isSingular(acc_phon_model, tol=1e-5) -->",
  isSingular(acc_phon_model, tol = 1e-5),
  "\n"
)

anova(acc_phon_model, acc_phon_model_null, test="Chisq") %>%
  formattable(
  caption="ANOVA of model and null model, assuming presence of register tier"
  )

x <- printTidyModel(acc_phon_model,
                    write_r2="Mode_PA_GLMM",
                    is_GLM = TRUE,
                    transform="exp",
                    show.intercept=TRUE,
                    type="est",
                    axis.lim = c(0.01, 10000)
                    )
x$r2
x$table


```


## Intercepts and Pairwise comparisons
```{r intercepts and pairwise tables}

charts <- getModelFixedFX(
  my_equation = acc_phon ~ mode + (1 | speaker),
  my_data = m_corpus,
  write="Mode_PA_GLMM",
  is_GLM=TRUE,
  extra_text = ", assuming presence of register tier"
)


charts$intercepts
charts$pairwise
```
