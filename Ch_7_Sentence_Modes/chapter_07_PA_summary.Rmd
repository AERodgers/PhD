---
title: 'Chapter 07: Analysis of Function: Sentence Modes'
output:
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE)
```

```{r warning=FALSE, message=FALSE}
# Load functions and packages
source("../functions/myFunctions.R")
installMissingPackages(
  c(
    "tidyverse",
    "knitr",
    "speakr",
    "formattable",
    "broomExtra",
    "ggpubr",
    "RColorBrewer",
    "tidymodels",
    # Include packages for %in% %notin% syntactic notation
    "mefa4"
  )
)

# PRAAT DIRECTORY
# Change this as required
options("speakr.praat.path" = "C:/Program Files/Praat/Praat.exe")

## set colours
my_colours <- c("#7b32942", "#c2a5cf","#a6dba0","#008837")
mode_colours <- c(
  "WHQ" = my_colours[3],
  "MDC" = my_colours[1],
  "MYN" = my_colours[4],
  "MDQ" = my_colours[2]
)


more_colours <- brewer.pal(6, "Spectral")
pitch_accent_colours <- c(
  "H*" = more_colours[4],
  "L*H" = more_colours[6],
  ">H*" = more_colours[5],
  "^[L*]H" = more_colours[3],
  "L*^[H]" = more_colours[2],
  "^[L*H]" = more_colours[1]
)

source("get_M_corpora.R")


m_corpus <- m_corpus %>% 
  select(speaker, gender, stim, mode, prompt, phr_phon, acc_phon, fin_phon, nuc_contour, speech_rate)
```


```{r}
# consolidate contour types

m_corpus_short <- m_corpus %>%
  mutate(
    nuc_contour = if_else(
      (nuc_contour == "^[L*H %]" | nuc_contour == "^[L*H L%]"),
      "^[L*H] %",
      if_else(nuc_contour == "L*^[H L%]",
              "L*^[H] %",
              nuc_contour)
    ),
    acc_phon = factor(
      str_replace(nuc_contour,
                  "\\s%$|\\sL%$",
                  ""),
      levels = c("H*", "L*H", ">H*", "^[L*]H", "L*^[H]", "^[L*H]")
    ),
    fin_phon = str_replace_all(fin_phon,
                               "L%]|%]",
                               "%")
  )

```

## **__1 Raw Data__**
```{r warning=FALSE}
# Calculate the number of tokens of each PN PA as a function of anacrusis.
# These are the raw, unadjusted values.

modes_nuc_summaries <- m_corpus_short %>%
  #filter(acc_phon %notin% c("H*", ">H*")) %>% 
  #mutate(acc_phon = str_replace_all(acc_phon, "\\^|\\[|\\]", "")) %>% 
  group_by(mode, acc_phon) %>%
  summarise(acc_count = n()) %>%
  spread(acc_phon,acc_count, is.na <- 0) %>% 
  # Save the results in a csv file
  write_csv("output/modes_nuc_raw.csv")
```

### Nuclear Pitch Accent by Sentence Mode

```{r warning=FALSE}
modes_nuc_summaries %>% 
  rename("\\^[L*]H" = "^[L*]H",
         "L*\\^[H]" = "L*^[H]",
         "\\^[L*H]" = "^[L*H]",
         "\\>H*" = ">H*") %>% 
  formattable()

```

### Nuclear Pitrch Accent by speaker
```{r warning=FALSE}
m_corpus_short %>%
  group_by(speaker, acc_phon) %>%
  summarise(acc_count = n(), .groups="keep") %>%
  spread(acc_phon, acc_count, is.na <- 0) %>%
  write_csv("output/nuc_by_speaker_raw.csv") %>%
  rename("\\^[L*]H" = "^[L*]H",
         "L*\\^[H]" = "L*^[H]",
         "\\^[L*H]" = "^[L*H]",
         "\\>H*" = ">H*") %>% 
  formattable()
```


## **__2 Adjusted Data__**

### Nuclear Pitch Accent by Sentence Mode
```{r warning=FALSE}
# Calculate the adjusted number of tokens of each NUC PA as a function of foot 
# size (the target variable). This takes into consideration the number of
# utterances per speaker per target variable and the number of speaker per
# target variable.

balancedData(m_corpus_short, stim, acc_phon, "", 11, 5, use_pa_hierarchy = FALSE) %>%
  rename(mode = stim) %>% 
  mutate(mode = substr(mode, 1, 3)) %>% group_by(mode) %>%
  
  pivot_longer(2:7, "acc_phon") %>% 
  mutate(
    acc_phon = factor(acc_phon,
                      levels = c(
                        "H*", "L*H", ">H*", "^[L*]H", "L*^[H]", "^[L*H]"
                        )
                      ),
    mode = factor(mode, levels = c("MDC", "MWH", "MYN", "MDQ"))
    ) %>% 
  group_by(acc_phon, mode) %>%
  summarise(acc_count = sum(value)) %>%
  spread(acc_phon,acc_count, is.na <- 0) %>% 
  
  write_csv("output/modes_nuc_balanced.csv") %>% 
  rename("\\^[L*]H" = "^[L*]H",
         "L*\\^[H]" = "L*^[H]",
         "\\^[L*H]" = "^[L*H]",
         "\\>H*" = ">H*") %>% 
  formattable()



```


```{r warning=FALSE}
# creat temp file addresses
my_table_m <- paste(getwd(), "/output/m_corpus_short_adj_M.csv", sep = "")
my_table_f <- paste(getwd(), "/output/m_corpus_short_adj_F.csv", sep = "")
my_table_g <-
  paste(getwd(), "/output/m_corpus_short_adj_G.csv", sep = "")



pivot_longer(
  balancedData(
    m_corpus_short, mode, acc_phon, "M", 5, 15, use_pa_hierarchy = FALSE
    ),
  c(2:7),
  names_to = "acc_phon"
  ) %>%
  write_csv(my_table_m)

pivot_longer(
  balancedData(
    m_corpus_short, mode, acc_phon, "F", 6, 15, use_pa_hierarchy = FALSE
    ),
  c(2:4),
  names_to = "acc_phon"
  ) %>%
  write_csv(my_table_f)

# run Praat script for generating representative fake balanced data.
# (This was faster than doing it in R for me!)
script <- "../PraatScripts/adjustedSummaryByGender.praat"
my_treatment <- "mode"
my_response <- "acc_phon"
my_count <- "value"

praat_run(script,
          my_treatment,
          my_response,
          my_count,
          my_table_m,
          my_table_f,
          my_table_g)

all <- read_csv(my_table_g, show_col_types = FALSE) %>%
  # Arrange PA levels according to hypothesized hierarchy.
  mutate(
    acc_phon = factor(
      acc_phon,
      levels = c("H*", "L*H", ">H*", "^[L*]H", "L*^[H]", "^[L*H]")
      ),
    mode = factor(mode, levels = c("MDC", "MWH", "MYN", "MDQ")))
```


```{r, fig.height=7, fig.width=15, eval=FALSE}
ggplot(all) +
  geom_bar(
    mapping = aes(x = mode, fill = acc_phon),
    colour = "black",
    show.legend = FALSE,
    position = position_dodge2(preserve = "single")
  ) +
  facet_grid(rows = vars(gender), cols = vars(acc_phon)) +
  ggtitle("Nuclear accents by sentence mode (adjusted)") +
  scale_fill_manual(values = pitch_accent_colours) +
  labs(x = "mode and gender",
       y = "tokens (n)") +
  theme(panel.border = element_rect(fill = NA))
```

```{r fig.height=4, fig.width=15}
ggplot(all) +
  geom_bar(
    mapping = aes(x = mode, fill = acc_phon),
    show.legend = FALSE,
    colour = "black",
    position = position_dodge2(preserve = "single")
  ) +
  facet_grid(cols = vars(acc_phon)) +
  theme(
    panel.border = element_rect(fill = NA),
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16)
    ) +
  #ggtitle("PNs across foot size conditions (adjusted)") +
  scale_fill_manual(values = pitch_accent_colours, name = "Pitch Accent") +
  labs(x = "foot size (syllables)", y = "tokens (n)") +
  theme(panel.border = element_rect(fill = NA))
    

unlink(c(my_table_m, my_table_f, my_table_g))
```
### Nuclear Pitch Accent by Speaker

```{r warning=FALSE}

nuc_by_speaker_ratio <- m_corpus_short %>%
    #filter (speaker == cur_speaker, .preserve = TRUE) %>%
    group_by(speaker, acc_phon) %>%
    summarise(nuc_count = n(), .groups = "keep") %>%
    spread(acc_phon, nuc_count, is.na <- 0, drop = FALSE) %>% 
    mutate(tot_PAs = sum(c_across())) %>% 
    mutate(across(1:7, ~ round(. / tot_PAs * 100))) %>% 
    select(-tot_PAs)

nuc_by_speaker_ratio %>% 
  write_csv("output/nuc_by_speaker_adj.csv")  %>% 
  rename("\\^[L*]H" = "^[L*]H",
         "L*\\^[H]" = "L*^[H]",
         "\\^[L*H]" = "^[L*H]",
         "\\>H*" = ">H*") %>% 
  formattable()

nuc_by_speaker_ratio_uncount <- nuc_by_speaker_ratio %>%
  gather("acc_phon", "count", -c(speaker)) %>%
  uncount(count) %>%
  mutate(acc_phon = factor(
    acc_phon,
    levels = c("H*", "L*H", ">H*", "^[L*]H", "L*^[H]", "^[L*H]")
  ))


# remove objects from global environment
rm(mean_speech_rate)
```


```{r warning=FALSE, fig.width = 8, fig.height = 4}
# Percentage Stacked bar

ggplot(data = nuc_by_speaker_ratio_uncount,
       aes(fill = acc_phon, x = speaker)) +
  geom_bar(
    stat = "count",
    position = "fill",
    width = 0.30,
    colour = "black"
  ) +
  scale_fill_manual(values = pitch_accent_colours[1:6]) +
  
  labs(x = "Proportion of nuclear Contours per speaker",
       y = "Speaker") +
  theme(panel.border = element_rect(fill = NA)) +
  scale_y_continuous(sec.axis = sec_axis( ~ . * 3 + 4))
```
