# OPEN SOUNDS & TEXTGRIDS CONTAINING SPECIFIED PHONOLOGICAL STRUCTURE
# ===================================================================
# Written for Praat 6.0.36

# Antoin Eoin Rodgers
# rodgeran@tcd.ie
# Phonetics and speech Laboratory, Trinity College Dublin
# May 22 2018

# Note this scripts requires the table generated by the "process_textgrids" script in order to work.
# The script will end with an error if the the target text does not exist in any phonological structure.

##############
### USER INPUT
form open textgrids containing given text in phonological analysis
    sentence target_text [
    optionmenu field 3
        option code
        option sentence
        option phonology
    optionmenu search_type 3
        option is equal to
        option is not equal to
        option contains
        option does not contain
        option starts with
        option does not start with
        option ends with
        option does not end with
        option contains a word equal to
        option does not contain a word equal to
        option contains a word starting with
        option does not contain a word starting with
        option contains a word ending with
        option does not contain a word ending with
        option matches (regex)

    sentence table_directory C:\Users\antoi\Github\PhD\Ch_6_Form\data
    sentence table_file a_corpus.csv
    comment Select tiers to HIDE ("syllable" is necessary)
    boolean ortho 1
    boolean rhythmic 0
    boolean phono 0
    boolean phonetic 1
    boolean vowel 1
    boolean tone 0
    boolean foExtrema 1
    boolean perpLine 1
    boolean maxK 1
    boolean hDur_LDur 1
    boolean comments 0
endform

field$# = {"code", "sentence", "phonology"}

search_type$[1] = "is equal to"
search_type$[2] = "is not equal to"
search_type$[3] = "contains"
search_type$[4] = "does not contain"
search_type$[5] = "starts with"
search_type$[6] = "does not start with"
search_type$[7] = "ends with"
search_type$[8] = "does not end with"
search_type$[9] = "contains a word equal to"
search_type$[10] = "does not contain a word equal to"
search_type$[11] = "contains a word starting with"
search_type$[12] = "does not contain a word starting with"
search_type$[13] = "contains a word ending with"
search_type$[14] = "does not contain a word ending with"
search_type$[15] = "matches (regex)"

# create vector of DB field names
db_field$# = {"code","sent","phr_phon"}

# create string of tiers to remove
hide_tiers$ = ""
if ortho = 1
    hide_tiers$ += "ortho "
endif
if rhythmic = 1
    hide_tiers$ += "rhythmic "
endif
if phono = 1
    hide_tiers$ += "phono "
endif
if phonetic = 1
    hide_tiers$ += "phonetic "
endif
if vowel = 1
    hide_tiers$ += "vowel "
endif
if tone = 1
    hide_tiers$ += "tone "
endif
if foExtrema = 1
    hide_tiers$ += "foExtrema "
endif
if perpLine = 1
    hide_tiers$ += "perpLine "
endif
if maxK = 1
    hide_tiers$ += "maxK "
endif
if hDur_LDur = 1
    hide_tiers$ += "HDur LDur "
endif
if comments = 1
    hide_tiers$ += "comments "
endif

last$ = right$(hide_tiers$, 1)
if last$ = " "
    hide_tiers$ = left$(hide_tiers$, length(hide_tiers$) - 1)
endif


### PROCESS FILES
# Get analysis table
table_directory$ = replace$(
                        ... replace$(table_directory$ + "/", "\", "/", 0),
                        ... "//",
                        ..."/",
                        ... 0)

# Get list of valid files
batch_data = Read Table from comma-separated file: table_directory$ + table_file$
temp_table = nowarn Extract rows where column (text):
         ... db_field$#[field], search_type$[search_type], target_text$
short_table =  nowarn Extract rows where: "self[""cur_foot""]=1"
num_rows = Get number of rows
removeObject: {batch_data, temp_table}



# write all indices and grid names in info window
my_text$ =  "Indices & File Codes'newline$'===================='newline$'"
my_text$ += newline$ +
    ... "+-----------------------+-----------------------+-------------------"
my_text$ += newline$ +  "|index" + tab$ + "file" +
            ... tab$ + tab$ + "| index" + tab$ + "file" +
            ... tab$ + tab$ + "|index" + tab$ + "file"
my_text$ += newline$ +
    ... "+-----------------------+-----------------------+-------------------"

i = 0
while i < num_rows
    i += 1
    cur_code$ = Get value: i, "code"
    my_text$ += newline$ + "| " + string$(i) + tab$ + cur_code$
    i += 1
    if i <= num_rows
        cur_code$ = Get value: i, "code"
        my_text$ += tab$ + "| " + string$(i) + tab$ + cur_code$
    endif
    i += 1
    if i <= num_rows
        cur_code$ = Get value: i, "code"
        my_text$ += tab$ + "| " + string$(i) + tab$ + cur_code$
    endif
endwhile


my_text$ += "'newline$''newline$''newline$'Looking for each " + field$#[field] +
            ... " which " + search_type$[search_type] + " ""'target_text$'""."

writeInfoLine: my_text$

# MAIN LOOP

# Menu Response Choices
edit_choice = 0
choice$[7] = "Save >"
choice$[6] = ">"
choice$[5] = "Retain >"
choice$[4] = "Save"
choice$[3] = "Undo"
choice$[2] = "<"
choice$[1] = "Exit"
choice$[0] = "Null"
edit_choice = 0
i = 0

while i < num_rows and choice$[edit_choice] != "Exit"
    i += 1

    selectObject: short_table
    cur_location$ = Get value: i, "location"
    curDrive$ = left$(cur_location$, 3)
    cur_location$ = replace$(
                        ... cur_location$,
                        ... curDrive$,
                        ... left$(table_directory$, 3),
                        ... 1
                        ... )
    cur_grid$ = Get value: i, "code"
    # avoid loading duplicate sounds and textgrids
        Read from file: cur_location$ + cur_grid$ + ".TextGrid"
        cur_grid = selected ()

        Read from file: cur_location$ + cur_grid$ + ".wav"
        Scale intensity: 70
        cur_sound = selected ()
        appendInfo: newline$, "Looking at: ", cur_grid$
        # remove tiers for temporary textgrid, if any have been specified
        if length(hide_tiers$) != 0
            @temp_textgrid: "cur_grid", hide_tiers$
            selectObject: temp_textgrid.object
            plusObject: cur_sound
        else
            selectObject: cur_grid
            plusObject: cur_sound
        endif

		# pause for editting
        Edit
        pauseText$ = "Editing 'i'/'num_rows': 'cur_grid$'"
        beginPause: pauseText$
            natural: "Jump to", i + 1
        edit_choice = endPause:
        ... "Exit", "<", "Undo", "Save", "Retain >" , ">", "Save >", 6, 0

        # Merge textgrid tiers.
        if length(hide_tiers$) != 0
            @merge_textgrids
        endif

        # Process Edit Choices
        if choice$[edit_choice] = "Save >"
            selectObject: cur_grid
            Save as text file: cur_location$ + cur_grid$ + ".TextGrid"
            i = jump_to - 1
        elsif choice$[edit_choice] = ">"
            i = jump_to - 1
        elsif choice$[edit_choice] = "Retain >"
            selectObject: cur_grid
            retain_name$ = selected$("TextGrid")
            Copy: retain_name$
            selectObject: cur_sound
            Copy: retain_name$
            i = jump_to - 1
        elsif choice$[edit_choice] = "Save"
            selectObject: cur_grid
            Save as text file: cur_location$ + cur_grid$ + ".TextGrid"
            i -= 1
        elsif choice$[edit_choice] = "Undo"
            i -= 1
        elsif choice$[edit_choice] = "<"
            i -= 2
        endif

        if i < 0
            i = 0
        endif

        #Remove Current Objects
        removeObject: {cur_grid, cur_sound}

    endif
endwhile

# remove unwanted objects
removeObject: short_table

include procs/tempTextGrids.proc
